# 2026-01-28 Devlog

## Readings Skill 迁移

### 任务
将 `apps/arkcore/src/readings.ts` 迁移到 Skill 架构。

### 技术决策

#### 1. ButtonHandler 扩展
Skill 系统原本只支持 `reactions` 和 `messages` 处理器，但 Readings 功能需要 Button 交互处理（标为已读/未读按钮）。

**决策**: 扩展 Skill 类型系统，新增 `ButtonHandler` 接口：
- `types.ts`: 新增 `ButtonHandler` 接口，使用 `customIdPrefix` 匹配
- `registry.ts`: 新增 `getAllButtonHandlers()` 方法
- `index.ts`: 注册 `interactionCreate` 事件监听器，路由到对应的 ButtonHandler

这种设计保持了与 ReactionHandler、MessageHandler 一致的模式，便于后续迁移其他使用按钮的功能（如 Diary）。

#### 2. LLM Client 实例化策略
原 `readings.ts` 在模块加载时创建 LLM client 并复用。Skill 架构中，`execute` 函数无法访问模块级状态。

**决策**: 在 message handler 的 `execute` 函数中按需创建 LLM client：
```typescript
const config = loadConfig();
const llmClient = createLlmClient(config);
```

权衡：略有性能开销，但保持了 skill 的无状态特性，更易测试和维护。

#### 3. 缓存保持模块级
`bookmarkedMessages` 和 `threadArticleUrls` 两个缓存保持模块级定义，因为：
- 需要跨请求持久化
- Skill 实例不提供生命周期钩子来管理状态
- 这与 voice.skill.ts 中的 `voiceQueue` 模式一致

### 变更文件
- `apps/arkcore/src/skills/types.ts`: 新增 ButtonHandler 类型
- `apps/arkcore/src/skills/registry.ts`: 新增 getAllButtonHandlers
- `apps/arkcore/src/skills/readings.skill.ts`: 新建，包含完整迁移
- `apps/arkcore/src/skills/index.ts`: 导出 readingsSkill
- `apps/arkcore/src/index.ts`: 注册 skill、添加 button handler wiring、注释掉 legacy 调用

### 已知问题
- TypeScript 编译有大量 discord.js 类型错误（pre-existing），但 tsc 仍能生成 JS 输出
- 建议后续升级 discord.js 或修复类型定义

---

## Editorial Skill 迁移

### 任务
将 `editorial-discussion.ts` 和 `editorial-translation.ts` 合并迁移到 Skill 架构。

### 技术决策

#### 1. 双 Handler 架构
Editorial 功能分为两种消息场景：
- **频道消息**: 在 editorial 频道发消息，触发创建讨论/翻译 thread
- **Thread 消息**: 在讨论 thread 中回复，触发 LLM 生成内容

**决策**: 创建两个 MessageHandler：
- `editorialChannelHandler`: 设置 `channelRole: "editorial"`，处理主频道消息
- `editorialThreadHandler`: 不设 `channelRole`，内部检查 thread parent 是否为 editorial 频道

原因：当前 skill 系统的 `channelRole` 过滤只检查 `message.channelId === configuredChannelId`，对于 thread 消息，其 `channelId` 是 thread 自己的 ID 而非 parent channel。因此 thread handler 需要自行获取配置并检查 `thread.parentId`。

#### 2. 合并 vs 分离
虽然 discussion 和 translation 是两个独立功能，但它们：
- 共享 editorial 频道配置
- 共享 LLM 调用逻辑
- 通过消息类型自然区分（forwarded = discussion, URL/text = translation）

**决策**: 合并为单一 `editorialChannelHandler`，通过 `isForwardedMessage()` 分支处理。避免两个 handler 同时匹配同一消息的复杂性。

#### 3. 跳过音频附件
Voice skill 也监听 editorial 频道的音频消息。为避免冲突：

**决策**: 在 `editorialChannelHandler.filter` 中显式排除音频附件消息：
```typescript
if (message.attachments.some((a) => a.contentType?.startsWith("audio/"))) return false;
```

#### 4. 共享工具函数
两个原文件有大量重复代码（prompt loading, LLM call, template rendering）。

**决策**: 在 skill 文件内部整合为统一的辅助函数，按功能分区：
- `// Shared` - 通用工具
- `// Discussion Helpers` - 讨论专用
- `// Translation Helpers` - 翻译专用

### 变更文件
- `apps/arkcore/src/skills/editorial.skill.ts`: 新建，合并 discussion + translation
- `apps/arkcore/src/skills/index.ts`: 导出 editorialSkill
- `apps/arkcore/src/index.ts`: 注册 editorialSkill、注释掉 legacy 调用
