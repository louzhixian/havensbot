# 2026-01-28 Devlog

## Readings Skill 迁移

### 任务
将 `apps/arkcore/src/readings.ts` 迁移到 Skill 架构。

### 技术决策

#### 1. ButtonHandler 扩展
Skill 系统原本只支持 `reactions` 和 `messages` 处理器，但 Readings 功能需要 Button 交互处理（标为已读/未读按钮）。

**决策**: 扩展 Skill 类型系统，新增 `ButtonHandler` 接口：
- `types.ts`: 新增 `ButtonHandler` 接口，使用 `customIdPrefix` 匹配
- `registry.ts`: 新增 `getAllButtonHandlers()` 方法
- `index.ts`: 注册 `interactionCreate` 事件监听器，路由到对应的 ButtonHandler

这种设计保持了与 ReactionHandler、MessageHandler 一致的模式，便于后续迁移其他使用按钮的功能（如 Diary）。

#### 2. LLM Client 实例化策略
原 `readings.ts` 在模块加载时创建 LLM client 并复用。Skill 架构中，`execute` 函数无法访问模块级状态。

**决策**: 在 message handler 的 `execute` 函数中按需创建 LLM client：
```typescript
const config = loadConfig();
const llmClient = createLlmClient(config);
```

权衡：略有性能开销，但保持了 skill 的无状态特性，更易测试和维护。

#### 3. 缓存保持模块级
`bookmarkedMessages` 和 `threadArticleUrls` 两个缓存保持模块级定义，因为：
- 需要跨请求持久化
- Skill 实例不提供生命周期钩子来管理状态
- 这与 voice.skill.ts 中的 `voiceQueue` 模式一致

### 变更文件
- `apps/arkcore/src/skills/types.ts`: 新增 ButtonHandler 类型
- `apps/arkcore/src/skills/registry.ts`: 新增 getAllButtonHandlers
- `apps/arkcore/src/skills/readings.skill.ts`: 新建，包含完整迁移
- `apps/arkcore/src/skills/index.ts`: 导出 readingsSkill
- `apps/arkcore/src/index.ts`: 注册 skill、添加 button handler wiring、注释掉 legacy 调用

### 已知问题
- TypeScript 编译有大量 discord.js 类型错误（pre-existing），但 tsc 仍能生成 JS 输出
- 建议后续升级 discord.js 或修复类型定义

---

## Editorial Skill 迁移

### 任务
将 `editorial-discussion.ts` 和 `editorial-translation.ts` 合并迁移到 Skill 架构。

### 技术决策

#### 1. 双 Handler 架构
Editorial 功能分为两种消息场景：
- **频道消息**: 在 editorial 频道发消息，触发创建讨论/翻译 thread
- **Thread 消息**: 在讨论 thread 中回复，触发 LLM 生成内容

**决策**: 创建两个 MessageHandler：
- `editorialChannelHandler`: 设置 `channelRole: "editorial"`，处理主频道消息
- `editorialThreadHandler`: 不设 `channelRole`，内部检查 thread parent 是否为 editorial 频道

原因：当前 skill 系统的 `channelRole` 过滤只检查 `message.channelId === configuredChannelId`，对于 thread 消息，其 `channelId` 是 thread 自己的 ID 而非 parent channel。因此 thread handler 需要自行获取配置并检查 `thread.parentId`。

#### 2. 合并 vs 分离
虽然 discussion 和 translation 是两个独立功能，但它们：
- 共享 editorial 频道配置
- 共享 LLM 调用逻辑
- 通过消息类型自然区分（forwarded = discussion, URL/text = translation）

**决策**: 合并为单一 `editorialChannelHandler`，通过 `isForwardedMessage()` 分支处理。避免两个 handler 同时匹配同一消息的复杂性。

#### 3. 跳过音频附件
Voice skill 也监听 editorial 频道的音频消息。为避免冲突：

**决策**: 在 `editorialChannelHandler.filter` 中显式排除音频附件消息：
```typescript
if (message.attachments.some((a) => a.contentType?.startsWith("audio/"))) return false;
```

#### 4. 共享工具函数
两个原文件有大量重复代码（prompt loading, LLM call, template rendering）。

**决策**: 在 skill 文件内部整合为统一的辅助函数，按功能分区：
- `// Shared` - 通用工具
- `// Discussion Helpers` - 讨论专用
- `// Translation Helpers` - 翻译专用

### 变更文件
- `apps/arkcore/src/skills/editorial.skill.ts`: 新建，合并 discussion + translation
- `apps/arkcore/src/skills/index.ts`: 导出 editorialSkill
- `apps/arkcore/src/index.ts`: 注册 editorialSkill、注释掉 legacy 调用

---

## Diary Skill 迁移

### 任务
将 `apps/arkcore/src/diary/` 目录的功能迁移到 Skill 架构。

### 技术决策

#### 1. Cron Job 架构
Diary 功能包含两个定时任务：
- 每日创建日记帖子 (默认 06:00)
- 每5分钟检查超时会话

**决策**: 使用 Skill 的 cron 系统（`SkillCronJob`），允许 per-guild 配置 cron 表达式：
- `dailyDiaryPostCron`: configKey="diaryCron"
- `diaryTimeoutCheckCron`: configKey="diaryTimeoutCron"

这比之前在 `scheduler.ts` 中硬编码 cron 更灵活，支持多租户场景。

#### 2. 双 Button Handler
Diary 有两个按钮：开始 (`diary_start`) 和结束 (`diary_end`)。

**决策**: 创建两个独立的 ButtonHandler：
- `diaryStartButtonHandler`: customIdPrefix="diary_start"
- `diaryEndButtonHandler`: customIdPrefix="diary_end"

由于按钮 ID 不共享前缀（不像 readings 的 `readings_toggle_`），分开处理更清晰。

#### 3. MessageHandler 的 channelRole 过滤
Diary 的消息处理需要：
1. 在 diary forum 的 thread 中
2. 有活跃的 session

**决策**: 设置 `channelRole: "diary"`，但由于 thread 的 channelId 不等于 forum 的 channelId，
skill 系统的 channelRole 过滤实际上不会匹配 thread 消息。因此在 `execute` 函数中通过
`getDiarySessionByThread()` 检查是否为活跃 diary thread。

这与 readings 的 Q&A handler 模式一致：设置 channelRole 作为语义标记，实际过滤在 handler 内部完成。

#### 4. LLM Client 按需创建
与其他 skill 一致，在 handler 的 `execute` 函数中按需创建 LLM client：
```typescript
const config = loadConfig();
const llmClient = createLlmClient(config);
```

#### 5. Scheduler 中的 Legacy Cron
`scheduler.ts` 中仍有 diary 相关的 cron job：
- `config.diaryCron` - 创建每日帖子
- `*/5 * * * *` - 超时检查

**决策**: 这些 legacy cron 依赖 `config.diaryEnabled` 和 `config.discordGuildId`，是单租户模式。
迁移后的 skill cron 支持多租户。暂时保留 legacy cron 以确保向后兼容，后续可以删除。

### 变更文件
- `apps/arkcore/src/skills/diary.skill.ts`: 新建，包含 message/button handlers 和 cron jobs
- `apps/arkcore/src/skills/index.ts`: 导出 diarySkill
- `apps/arkcore/src/index.ts`: 注册 diarySkill、注释掉 legacy handler 调用
