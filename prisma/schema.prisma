generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum SourceType {
  RSS
}

enum ContentQuality {
  title_only
  snippet
  fulltext
}

enum EditorialReportStatus {
  success
  failed
}

enum MetricType {
  llm_call
  rss_fetch
  digest_run
  editorial_run
  deeper_run
  whisper_transcribe
  error
  discord_message
  system
}

enum MetricStatus {
  success
  failure
  degraded
}

enum AlertType {
  llm_failure_rate
  llm_cost_high
  llm_token_limit
  storage_warning
  rss_failure
  digest_failure
  editorial_failure
}

enum AlertSeverity {
  info
  warning
  error
  critical
}

model Source {
  id            String     @id @default(cuid())
  channelId     String
  type          SourceType
  name          String
  url           String
  enabled       Boolean    @default(true)
  etag          String?
  lastModified  String?
  lastFetchedAt DateTime?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  items         Item[]

  @@unique([channelId, type, url])
}

model Item {
  id                  String          @id @default(cuid())
  sourceId            String
  title               String
  url                 String
  publishedAt         DateTime?
  contentSnippet      String?
  contentHash         String
  contentQuality      ContentQuality?
  writingSuggestions  Json?
  enrichedAt          DateTime?
  enrichErrorReason   String?
  deepDive            String?         @db.Text
  deepDiveAt          DateTime?
  deepDiveErrorReason String?
  archivedAt          DateTime?
  createdAt           DateTime        @default(now())
  source              Source          @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@unique([sourceId, contentHash])
  @@index([createdAt])
  @@index([archivedAt])
  @@index([sourceId, createdAt])
}

model Digest {
  id         String   @id @default(cuid())
  channelId  String
  rangeStart DateTime
  rangeEnd   DateTime
  content    String   @db.Text
  createdAt  DateTime @default(now())
}

model EditorialReport {
  id          String                @id @default(cuid())
  channelId   String
  windowStart DateTime
  windowEnd   DateTime
  status      EditorialReportStatus
  content     String                @db.Text
  meta        Json?
  createdAt   DateTime              @default(now())
}

model ObservabilityMetric {
  id        String       @id @default(cuid())
  type      MetricType
  operation String
  status    MetricStatus
  metadata  Json?
  createdAt DateTime     @default(now())

  @@index([type, createdAt])
  @@index([status, createdAt])
  @@index([operation, createdAt])
}

model SystemAlert {
  id         String        @id @default(cuid())
  alertType  AlertType
  severity   AlertSeverity
  message    String
  metadata   Json?
  resolved   Boolean       @default(false)
  resolvedAt DateTime?
  notifiedAt DateTime?
  createdAt  DateTime      @default(now())

  @@index([resolved, severity, createdAt])
}

model DiarySession {
  id           String    @id @default(cuid())
  guildId      String    // D-02: Added for guild-scoped timeout checks
  userId       String    // D-04: Added for per-user concurrency limit
  date         DateTime  @db.Date
  threadId     String    @unique
  channelId    String
  startedAt    DateTime  @default(now())
  endedAt      DateTime?
  endReason    String?
  messageCount Int       @default(0)
  exportPath   String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([date])
  @@index([channelId])
  @@index([guildId, endedAt]) // D-02: For efficient guild-scoped queries
  @@index([guildId, userId, endedAt]) // D-04: For checking user's active sessions
}

enum ChannelConfigRole {
  digest_source
  digest_output
  deep_dive_output
  diary
  favorites
  editorial
  readings
}

model ChannelConfig {
  id           String            @id @default(cuid())
  guildId      String
  channelId    String?
  categoryId   String?
  role         ChannelConfigRole
  digestCron   String?
  digestFormat String?
  enabled      Boolean           @default(true)
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt

  @@unique([guildId, channelId, role])
  @@unique([guildId, categoryId, role])
  @@index([guildId, role])
}

model GuildSettings {
  id              String    @id @default(cuid())
  guildId         String    @unique

  // Basic config
  timezone        String    @default("UTC")
  locale          String    @default("en")

  // Subscription
  tier            String    @default("free")  // free | premium | suspended
  tierExpiresAt   DateTime?

  // Skills
  enabledSkills   String[]  @default(["digest", "favorites"])

  // Quotas
  rssSourceLimit  Int       @default(10)
  llmDailyQuota   Int       @default(0)
  llmUsedToday    Int       @default(0)
  llmQuotaResetAt DateTime?

  // Skill-specific configs (JSON)
  skillConfigs    Json      @default("{}")

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  subscription    Subscription?

  @@index([tier])
}

model Subscription {
  id                String        @id @default(cuid())
  guildId           String        @unique

  // LemonSqueezy
  lemonSqueezyId    String        @unique  // subscription_id
  customerId        String                 // customer_id
  variantId         String                 // price/plan ID

  status            String                 // active | past_due | canceled | expired
  currentPeriodEnd  DateTime               // Current billing period end
  cancelAtPeriodEnd Boolean       @default(false)

  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  guild             GuildSettings @relation(fields: [guildId], references: [guildId], onDelete: Cascade)

  @@index([status])
  @@index([currentPeriodEnd])
}

model BillingEvent {
  id              String   @id @default(cuid())
  guildId         String?           // Nullable for events without guild context

  type            String            // subscription_created | payment_success | subscription_canceled | ...
  lemonSqueezyId  String   @unique  // event_id (prevent duplicate processing)
  payload         Json              // Full webhook payload

  createdAt       DateTime @default(now())

  @@index([guildId])
  @@index([type, createdAt])
}

model GuildTemplate {
  id          String   @id @default(cuid())
  name        String   @unique
  description String
  structure   Json     // Template structure (categories, channels, roles)
  isBuiltin   Boolean  @default(false)
  createdBy   String?  // guildId, null for builtin templates
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// Generic key-value cache for replacing in-memory Maps
// Addresses: V-01, R-01, R-02, F-01 (memory cache persistence issues)
model CacheEntry {
  id        String    @id @default(cuid())
  namespace String    // e.g., "voice_retry", "readings_bookmark", "favorites_forward"
  key       String    // Original Map key
  value     Json      // Original Map value
  expiresAt DateTime? // Optional TTL
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@unique([namespace, key])
  @@index([namespace])
  @@index([expiresAt])
}

// R-03: Prevent concurrent creation of duplicate reading bookmarks
model ReadingBookmark {
  id         String   @id @default(cuid())
  guildId    String   // Guild where bookmark was created
  messageId  String   @unique  // Original message ID (prevent duplicates)
  threadId   String   // Forum thread ID
  channelId  String   // Source channel ID
  userId     String   // User who bookmarked
  articleUrl String?  // Article URL (if extracted)
  createdAt  DateTime @default(now())

  @@index([guildId])
  @@index([threadId])
}
